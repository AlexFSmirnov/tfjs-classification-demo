{"version":3,"sources":["constants/index.ts","utils/normalizePrediction.ts","utils/getEmptyPrediction.ts","components/Button/style.ts","components/Button/Button.tsx","components/CharacterCanvas/style.ts","components/CharacterCanvas/CharacterCanvas.tsx","components/PredictionMapCell/style.ts","components/PredictionMapCell/PredictionMapCell.tsx","components/PredictionMap/style.ts","components/PredictionMap/PredictionMap.tsx","style.ts","App.tsx","serviceWorkerRegistration.ts","index.tsx"],"names":["IMAGE_SIZE","CLASSES","NORMALIZED_CLASSES","normalizePrediction","prediction","normalizedPrediction","map","_","forEach","hexClass","i","hexValue","split","length","char","String","fromCharCode","parseInt","toUpperCase","indexOf","minValue","Math","min","maxValue","max","value","result","topCandidate","getEmptyPrediction","ButtonElement","styled","div","Button","children","onClick","e","CharacterCanvasWrapperElement","CanvasElement","canvas","CharacterCanvas","onChange","onPointerUp","canvasRef","useRef","previousPointerPosition","onChangeLastCalled","clear","current","ctx","getContext","beginPath","rect","fillStyle","fill","useEffect","canvasProps","ref","width","height","onPointerMove","buttons","clientX","clientY","x","getBoundingClientRect","y","prevX","prevY","moveTo","lineTo","lineWidth","stroke","now","Date","getTime","row","getImageData","data","r","g","b","push","getPixels","PredictionMapCellWrapper","props","pow","PredictionMapCell","PredictionMapWrapper","PredictionMapContainer","PredictionMap","Object","keys","k","AppWrapper","Candidate","LoadingText","App","model","state","loadModel","a","loadLayersModel","process","forceUpdate","predict","pixels","inputTensor","tensor","Array","from","dataSync","setState","handleCanvasChange","this","React","Component","isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","controller","console","log","onUpdate","onSuccess","catch","error","ReactDOM","render","StrictMode","document","getElementById","URL","href","origin","addEventListener","fetch","headers","response","contentType","get","status","ready","unregister","reload","checkValidServiceWorker","serviceWorkerRegistration"],"mappings":"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","file":"static/js/main.458db85a.chunk.js","sourcesContent":["export const IMAGE_SIZE = 32;\r\n\r\nexport const CANVAS_SCALE = 8;\r\nexport const CANVAS_LINE_WIDTH = 2;\r\nexport const CANVAS_BACKGROUND_COLOR = 'white';\r\n\r\nexport const CLASSES = ['30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '41', '42', '43_63', '44', '45', '46', '47', '48', '49_69', '4a_6a', '4b_6b', '4c_6c', '4d_6d', '4e', '4f_6f', '50_70', '51', '52', '53_73', '54', '55_75', '56_76', '57_77', '58_78', '59_79', '5a_7a', '61', '62', '64', '65', '66', '67', '68', '6e', '71', '72', '74'];\r\nexport const NORMALIZED_CLASSES = ['A', 'B', 'C', 'D',  'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];","import { CLASSES, NORMALIZED_CLASSES } from '../constants';\r\n\r\nexport const normalizePrediction = (prediction: number[]) => {\r\n    let normalizedPrediction = NORMALIZED_CLASSES.map(_ => 0);\r\n    CLASSES.forEach((hexClass, i) => {\r\n        const hexValue = hexClass.split('_')[hexClass.split('_').length - 1];\r\n        const char = String.fromCharCode(parseInt(hexValue, 16)).toUpperCase();\r\n\r\n        normalizedPrediction[NORMALIZED_CLASSES.indexOf(char)] += prediction[i];\r\n    });\r\n\r\n    const minValue = Math.min(...normalizedPrediction);\r\n    const maxValue = Math.max(...normalizedPrediction) - minValue;\r\n    normalizedPrediction = normalizedPrediction\r\n        .map(value => value - minValue)\r\n        .map(value => value / maxValue);\r\n\r\n    const result: Record<string, number> = {}\r\n    NORMALIZED_CLASSES.forEach(char => {\r\n        result[char] = normalizedPrediction[NORMALIZED_CLASSES.indexOf(char)];\r\n    });\r\n\r\n    return {\r\n        topCandidate: NORMALIZED_CLASSES[normalizedPrediction.indexOf(Math.max(...normalizedPrediction))],\r\n        prediction: result,\r\n    };\r\n};\r\n","import { NORMALIZED_CLASSES } from '../constants';\r\n\r\nexport const getEmptyPrediction = () => {\r\n    const result: Record<string, number> = {}\r\n    NORMALIZED_CLASSES.forEach(char => {\r\n        result[char] = 0;\r\n    });\r\n\r\n    return result;\r\n};\r\n","import styled from 'styled-components';\r\n\r\nexport const ButtonElement = styled.div`\r\n    width: 100%;\r\n    padding: 8px 2px;\r\n    border-radius: 4px;\r\n\r\n    text-align: center;\r\n    user-select: none;\r\n    font-size: 18pt;\r\n    color: white;\r\n    background-color: #444;\r\n\r\n    transition: background-color 200ms;\r\n\r\n    &:hover {\r\n        background-color: #3a3a3a;\r\n    }\r\n\r\n    &:active {\r\n        background-color: #222;\r\n    }\r\n`;\r\n","import React from 'react';\r\nimport { ButtonElement } from './style';\r\n\r\nexport interface ButtonProps {\r\n    children: React.ReactNode;\r\n    onClick?: (e: React.MouseEvent<HTMLDivElement>) => void;\r\n}\r\n\r\nconst Button: React.FC<ButtonProps> = ({ children, onClick }) => {\r\n    const handleClick = (e: React.MouseEvent<HTMLDivElement>) => {\r\n        if (onClick) {\r\n            onClick(e);\r\n        }\r\n    };\r\n\r\n    return (\r\n        <ButtonElement onClick={handleClick}>{children}</ButtonElement>\r\n    );\r\n};\r\n\r\nexport default Button;\r\n","import styled from 'styled-components';\r\nimport { IMAGE_SIZE, CANVAS_SCALE } from '../../constants';\r\n\r\nexport const CharacterCanvasWrapperElement = styled.div`\r\n    width: ${IMAGE_SIZE * CANVAS_SCALE}px;\r\n    padding: 8px;\r\n\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center;\r\n`;\r\n\r\nexport const CanvasElement = styled.canvas`\r\n    width: ${IMAGE_SIZE * CANVAS_SCALE}px;\r\n    height: ${IMAGE_SIZE * CANVAS_SCALE}px;\r\n    margin-bottom: 8px;\r\n\r\n    border: 2px solid #444;\r\n    border-radius: 8px;\r\n\r\n    image-rendering: pixelated;\r\n    image-rendering: -moz-crisp-edges;\r\n    image-rendering: crisp-edges;\r\n`;\r\n","import React, { useRef, useEffect } from 'react';\r\nimport { IMAGE_SIZE, CANVAS_LINE_WIDTH, CANVAS_BACKGROUND_COLOR, CANVAS_SCALE } from '../../constants';\r\nimport { Button } from '../Button';\r\nimport { CharacterCanvasWrapperElement, CanvasElement } from './style';\r\n\r\nconst CANVAS_UPDATE_TIMEOUT = 200;\r\n\r\nexport interface CharacterCanvasProps {\r\n    onChange?: (pixels: number[][][] | null) => void;\r\n    onPointerUp?: () => void;\r\n}\r\n\r\nconst CharacterCanvas: React.FC<CharacterCanvasProps> = ({ onChange, onPointerUp }) => {\r\n    const canvasRef = useRef<HTMLCanvasElement>(null);\r\n    const previousPointerPosition = useRef<{ x: number, y: number } | null>(null);\r\n    const onChangeLastCalled = useRef<number>(0);\r\n\r\n    const clear = () => {\r\n        const { current: canvas } = canvasRef;\r\n        if (canvas) {\r\n            const ctx = canvas.getContext('2d');\r\n            if (ctx) {\r\n                ctx.beginPath();\r\n                ctx.rect(0, 0, IMAGE_SIZE, IMAGE_SIZE);\r\n                ctx.fillStyle = CANVAS_BACKGROUND_COLOR;\r\n                ctx.fill();\r\n            }\r\n        }\r\n    }\r\n\r\n    useEffect(clear, [canvasRef]);\r\n\r\n    const getPixels = () => {\r\n        const { current: canvas } = canvasRef;\r\n        if (!canvas) {\r\n            return null;\r\n        }\r\n\r\n        const ctx = canvas.getContext('2d');\r\n        if (!ctx) {\r\n            return null;\r\n        }\r\n\r\n        const result: number[][][] = [];\r\n        for (let y = 0; y < IMAGE_SIZE; ++y) {\r\n            const row: number[][] = [];\r\n            for (let x = 0; x < IMAGE_SIZE; ++x) {\r\n                const [r, g, b] = ctx.getImageData(x, y, 1, 1).data;\r\n                row.push([r / 255, g / 255, b / 255]);\r\n            }\r\n            result.push(row);\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    const handlePointerMove = (e: React.PointerEvent<HTMLCanvasElement>) => {\r\n        const { current: canvas } = canvasRef;\r\n        if (canvas) {\r\n            const ctx = canvas.getContext('2d');\r\n            if (ctx) {\r\n                const { buttons, clientX, clientY } = e;\r\n                const x = (clientX - canvas.getBoundingClientRect().x) / CANVAS_SCALE;\r\n                const y = (clientY - canvas.getBoundingClientRect().y) / CANVAS_SCALE;\r\n\r\n                if (!buttons) {\r\n                    previousPointerPosition.current = null;\r\n                    return;\r\n                }\r\n\r\n                if (previousPointerPosition.current) {\r\n                    // A little hack to make the line darker on a small resolution canvas\r\n                    for (let i = 0; i < 5; ++i) {\r\n                        const { current: { x: prevX, y: prevY } } = previousPointerPosition;\r\n                        ctx.beginPath();\r\n                        ctx.moveTo(prevX, prevY);\r\n                        ctx.lineTo(x, y);\r\n                        ctx.lineWidth = CANVAS_LINE_WIDTH;\r\n                        ctx.stroke();\r\n                    }\r\n                }\r\n\r\n                previousPointerPosition.current = { x, y };\r\n            }\r\n        }\r\n\r\n        const now = (new Date()).getTime();\r\n        if (onChange && now - onChangeLastCalled.current > CANVAS_UPDATE_TIMEOUT) {\r\n            onChangeLastCalled.current = now;\r\n            onChange(getPixels());\r\n        }\r\n    };\r\n\r\n    const handlePointerUp = () => {\r\n        previousPointerPosition.current = null\r\n\r\n        if (onPointerUp) {\r\n            onPointerUp();\r\n        }\r\n    };\r\n\r\n    const canvasProps = {\r\n        ref: canvasRef,\r\n        width: IMAGE_SIZE,\r\n        height: IMAGE_SIZE,\r\n        onPointerMove: handlePointerMove,\r\n        onPointerUp: handlePointerUp,\r\n    };\r\n\r\n    return (\r\n        <CharacterCanvasWrapperElement>\r\n            <CanvasElement {...canvasProps} />\r\n            <Button onClick={clear}>Clear</Button>\r\n        </CharacterCanvasWrapperElement>\r\n    );\r\n};\r\n\r\nexport default CharacterCanvas;\r\n","import styled from 'styled-components';\r\n\r\nexport interface PredictionMapCellWrapperProps {\r\n    value: number;\r\n}\r\n\r\nexport const PredictionMapCellWrapper = styled.div<PredictionMapCellWrapperProps>`\r\n    width: 64px;\r\n    height: 64px;\r\n    margin: 10px;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    border-radius: 4px;\r\n    background-color: rgb(0, 255, 0, ${props => Math.pow(props.value, 15)});\r\n    font-size: 18pt;\r\n`;\r\n","import React from 'react';\r\nimport { PredictionMapCellWrapper } from './style';\r\n\r\nexport interface PredictionMapCellProps {\r\n    value: number;\r\n    children: React.ReactNode;\r\n}\r\n\r\nconst PredictionMapCell: React.FC<PredictionMapCellProps> = ({ value, children }) => {\r\n\r\n    return (\r\n        <PredictionMapCellWrapper value={value}>\r\n            {children}\r\n        </PredictionMapCellWrapper>\r\n    )\r\n};\r\n\r\nexport default PredictionMapCell;\r\n","import styled from 'styled-components';\r\n\r\nexport const PredictionMapWrapper = styled.div`\r\n    height: 300px;\r\n    margin-top: 2px;\r\n\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n`;\r\n\r\nexport const PredictionMapContainer = styled.div`\r\n    height: 336px;\r\n    width: 756px;\r\n    margin: 8px;\r\n\r\n    display: flex;\r\n    flex-wrap: wrap;\r\n`;\r\n","import React from 'react';\r\nimport { PredictionMapCell } from '../PredictionMapCell';\r\nimport { PredictionMapContainer, PredictionMapWrapper } from './style';\r\n\r\nexport interface PredictionMapProps {\r\n    prediction: Record<string, number>;\r\n}\r\n\r\nconst PredictionMap: React.FC<PredictionMapProps> = ({ prediction }) => {\r\n\r\n    return (\r\n        <PredictionMapWrapper>\r\n            <PredictionMapContainer>\r\n                {Object.keys(prediction).map(k => (\r\n                    <PredictionMapCell key={k} value={prediction[k]}>{k}</PredictionMapCell>\r\n                ))}\r\n            </PredictionMapContainer>\r\n        </PredictionMapWrapper>\r\n    )\r\n};\r\n\r\nexport default PredictionMap;\r\n","import styled from 'styled-components';\r\n\r\nexport const AppWrapper = styled.div`\r\n    width: 1304px;\r\n    height: 329px;\r\n    padding: 12px 0px;\r\n    padding-right: 2px;\r\n    padding-left: 16px;\r\n\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n\r\n    box-shadow: 0 0 16px rgba(0, 0, 0, 0.5);\r\n    border-radius: 16px;\r\n`;\r\n\r\nexport const Candidate = styled.div`\r\n    width: 256px;\r\n    height: 309px;\r\n    border: 2px solid #444;\r\n    border-radius: 8px;\r\n\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n\r\n    font-size: 156pt;\r\n`;\r\n\r\nexport const LoadingText = styled.div`\r\n    font-size: 50pt;\r\n`;\r\n","import React from 'react';\nimport { loadLayersModel, tensor, LayersModel, Tensor } from '@tensorflow/tfjs';\nimport { normalizePrediction } from './utils/normalizePrediction';\nimport { getEmptyPrediction } from './utils/getEmptyPrediction';\nimport { CharacterCanvas, PredictionMap } from './components';\nimport { IMAGE_SIZE } from './constants';\nimport { AppWrapper, Candidate, LoadingText } from './style';\n\nexport interface AppState {\n    prediction: Record<string, number>;\n    topCandidate: string;\n}\n\nclass App extends React.Component<{}, AppState> {\n    private model: LayersModel | null = null;\n    private prediction: Record<string, number> = {};\n\n    state = {\n        prediction: getEmptyPrediction(),\n        topCandidate: '?',\n    };\n\n    componentDidMount() {\n        this.loadModel();\n    }\n\n    loadModel = async () => {\n        this.model = await loadLayersModel(`${process.env.PUBLIC_URL}/model/model.json`);\n        this.forceUpdate();\n    };\n\n    predict = (pixels: number[][][]) => {\n        if (!this.model) {\n            return;\n        }\n\n        const inputTensor = tensor([pixels], [1, IMAGE_SIZE, IMAGE_SIZE, 3]);\n\n        const result = this.model.predict(inputTensor) as Tensor;\n        const { topCandidate, prediction } = normalizePrediction(Array.from(result.dataSync()));\n\n        this.prediction = prediction;\n        this.setState({ topCandidate, prediction });\n    };\n\n    handleCanvasChange = (pixels: number[][][] | null) => {\n        if (!pixels) {\n            return;\n        }\n\n        this.predict(pixels);\n    };\n\n    render() {\n        const { prediction, topCandidate } = this.state;\n\n        return (\n            <AppWrapper>\n                {this.model\n                    ? (\n                        <>\n                            <Candidate>{topCandidate}</Candidate>\n                            <CharacterCanvas onChange={this.handleCanvasChange} />\n                            <PredictionMap prediction={prediction} />\n                        </>\n                    )\n                    : (\n                        <LoadingText>Model loading...</LoadingText>\n                    )\n                }\n            </AppWrapper>\n        );\n    }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://cra.link/PWA\n\nconst isLocalhost = Boolean(\n    window.location.hostname === 'localhost' ||\n        // [::1] is the IPv6 localhost address.\n        window.location.hostname === '[::1]' ||\n        // 127.0.0.0/8 are considered localhost for IPv4.\n        window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\ntype Config = {\n    onSuccess?: (registration: ServiceWorkerRegistration) => void;\n    onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n    if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n        // The URL constructor is available in all browsers that support SW.\n        const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n        if (publicUrl.origin !== window.location.origin) {\n            // Our service worker won't work if PUBLIC_URL is on a different origin\n            // from what our page is served on. This might happen if a CDN is used to\n            // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n            return;\n        }\n\n        window.addEventListener('load', () => {\n            const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n            if (isLocalhost) {\n                // This is running on localhost. Let's check if a service worker still exists or not.\n                checkValidServiceWorker(swUrl, config);\n\n                // Add some additional logging to localhost, pointing developers to the\n                // service worker/PWA documentation.\n                navigator.serviceWorker.ready.then(() => {\n                    console.log(\n                        'This web app is being served cache-first by a service ' +\n                            'worker. To learn more, visit https://cra.link/PWA'\n                    );\n                });\n            } else {\n                // Is not localhost. Just register service worker\n                registerValidSW(swUrl, config);\n            }\n        });\n    }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n    navigator.serviceWorker\n        .register(swUrl)\n        .then((registration) => {\n            registration.onupdatefound = () => {\n                const installingWorker = registration.installing;\n                if (installingWorker == null) {\n                    return;\n                }\n                installingWorker.onstatechange = () => {\n                    if (installingWorker.state === 'installed') {\n                        if (navigator.serviceWorker.controller) {\n                            // At this point, the updated precached content has been fetched,\n                            // but the previous service worker will still serve the older\n                            // content until all client tabs are closed.\n                            console.log(\n                                'New content is available and will be used when all ' +\n                                    'tabs for this page are closed. See https://cra.link/PWA.'\n                            );\n\n                            // Execute callback\n                            if (config && config.onUpdate) {\n                                config.onUpdate(registration);\n                            }\n                        } else {\n                            // At this point, everything has been precached.\n                            // It's the perfect time to display a\n                            // \"Content is cached for offline use.\" message.\n                            console.log('Content is cached for offline use.');\n\n                            // Execute callback\n                            if (config && config.onSuccess) {\n                                config.onSuccess(registration);\n                            }\n                        }\n                    }\n                };\n            };\n        })\n        .catch((error) => {\n            console.error('Error during service worker registration:', error);\n        });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n    // Check if the service worker can be found. If it can't reload the page.\n    fetch(swUrl, {\n        headers: { 'Service-Worker': 'script' },\n    })\n        .then((response) => {\n            // Ensure service worker exists, and that we really are getting a JS file.\n            const contentType = response.headers.get('content-type');\n            if (\n                response.status === 404 ||\n                (contentType != null && contentType.indexOf('javascript') === -1)\n            ) {\n                // No service worker found. Probably a different app. Reload the page.\n                navigator.serviceWorker.ready.then((registration) => {\n                    registration.unregister().then(() => {\n                        window.location.reload();\n                    });\n                });\n            } else {\n                // Service worker found. Proceed as normal.\n                registerValidSW(swUrl, config);\n            }\n        })\n        .catch(() => {\n            console.log('No internet connection found. App is running in offline mode.');\n        });\n}\n\nexport function unregister() {\n    if ('serviceWorker' in navigator) {\n        navigator.serviceWorker.ready\n            .then((registration) => {\n                registration.unregister();\n            })\n            .catch((error) => {\n                console.error(error.message);\n            });\n    }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport './index.css';\nimport * as serviceWorkerRegistration from './serviceWorkerRegistration';\n\nReactDOM.render(\n    <React.StrictMode>\n        <App />\n    </React.StrictMode>,\n    document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://cra.link/PWA\nserviceWorkerRegistration.register();\n"],"sourceRoot":""}